# 实数的浮点数表示方法

当使用有限精度的计算机存储单元来表示真实的、无限精度的数字时，
舍入误差是不可避免的。  



**浮点数格式**  IEEE标准由一组实数的二进制表示法组成。浮点数由三部分组成：符号($+$或$-$)、尾数(包含有效位)和指数。这三个部分一起存储在一个计算机字节中。

浮点数有三种常用的精度级别：单精度、双精度和扩展精度，也称为长
双精度。分配给三种格式的每个浮点数的位数分别为$32$、$64$和$80$。按如下
方式在各部分之间划分比特:  

| precision   | sign | exponent | mantissa |
| ----------- | ---- | -------- | -------- |
| signal      | $1$  | $8$      | $23$     |
| double      | $1$  | $11$     | $52$     |
| long double | $1$  | $15$     | $64$     |

这三种精确度的工作原理基本相同。归一化IEEE浮点数的形式为：
$$
\pm 1.bbb\cdots b\times2^p
$$
其中每个$b$为$0$或$1$，并且$p$为表示指数的一个$M$比特的二进制数。

当二进制数存储为规格化浮点数时，他是“左对齐”的，这意味着最左边的$1$正好移到基点的左边。指数的变化补偿了这种移位。例如，十进制数字$9$(二进制位$1001$)将存储为
$$
+1.001\times 2^3
$$
双精度的数字$1$为
$$
+1.0000000000000000000000000000000000000000000000000000  \times 2^{0}
$$
其中我们有$52$位尾数。比$1$大的下一个浮点数为：
$$
+1.0000000000000000000000000000000000000000000000000001  \times 2^{0}
$$
或者$1+2^{-52}$。

机器的经度(**machine epsilon**)，表示为$\epsilon_{\operatorname{match}}$，是$1$和比$1$大离$1$最近的浮点数的距离。对于IEEE双精度浮点数标准：
$$
\epsilon_{\operatorname{match}} = 2^{-52}
$$
十进制数$9.4 = (1001.\overline{0110})_2$左对齐为
$$
+1.0010110011001100110011001100110011001100110011001100110 \ldots \times 2^{3},
$$
其中我们有$52$位尾数。这就产生了新的问题：我们如何将表示$9.4$的无限二进制数放在有限的位数中？

我们必须用某种方法截断数字，但是这样做我们不可避免地会造成误差。一种方法，叫做截断(**chopping**)，简单地将超过地位数截断掉。这种方法很简单，但是它总是将结果移向$0$，这是有偏见的。

另一种方法是四舍五入(**rounding**)。以二进制表示，如果位为$1$，向上舍入。具体的说，在双精度数中看第$53$位。由IEEE标准实现的默认舍入技术是，如果$53$位是$1$，则将$1$加到位$52$上(向上舍入)，如果位$53$是$0$，则不对$52$位做任何操作(向下舍入)，但有一个例外：如果位$52$后面的位是$10000\cdots$，恰好在向上和向下的中间，我们根据那个选择使最后的位$52$等于$0$而向上舍入或向下舍入。那么$9.4$就可以表示为
$$
+1.0010110011001100110011001100110011001100110011001101 \times 2^{3}
$$
向上取整。

***

定义 0.2  用$fl(x)$表示与$x$关联的IEEE双精度浮点数，使用四舍五入到最接近的规则。

在电脑计算中，实数$x$被比特串$fl(x)$替换。我们通过从数字的结尾的右边丢弃无穷大的尾巴$.\overline{1100}\times2^{-52}\times2^3 = 0.4\times 2^{-48}$然后加上$2^{-52}\times 2^3 = 2^{-49}$来执行舍入步骤。因此
$$
\begin{aligned}
\operatorname{fl}(9.4) &= 9.4 + 2^{-49} - 0.4\times 2^{-48}\\
&= 9.4 + (1-0.8)\times2^{-49}\\
&= 9.4 + 0.2\times2^{-49}
\end{aligned}
$$
也就是说当计算机用双精度存储$9.4$的误差为$0.2\times 2^{-49}$。我们称此误差为舍入误差(**rounding error**)。

定义0.3  设$x_c$是$x$的计算版本。则
$$
\text{绝对误差} = |x_c-x|
$$
和
$$
\text{相对误差} = \frac{|x_c-x|}{|x|}
$$
**相对舍入误差**

在IEEE机器计算模型中，$\operatorname{fl}(x)$的相对舍入误差不超过机器精度的一半：
$$
\frac{|\operatorname{fl}(x)-x|}{|x|}\le \frac{1}{2}\epsilon_{\operatorname{match}}
$$

## 机器表示(Machine representation)

截至到现在，我们已经抽象地描述了一个浮点数的表示方法。以下是有关如何在计算机上实现此表示法的更多详细信息。同样的，我们将只讨论双精度的，其他精度的原理类似。

每个双精度浮点数都分配一个$8$字节的字(即$64$位)来储存它的三个部分。
$$
se_1e_2\cdots e_{11}b_1b_2\cdots b_{52}
$$
第一位存储符号，后跟表示指数的$11$位和小数点后表示尾数的$52$位。符号位$0$表示正数，$1$表示负数。$11$比特表示指数从$-1022\sim 1023$。这覆盖了$e_1\cdots e_{11}$从$1$到$2046$，留下$0$和$2047$用作其他用途，我们将要稍后讨论这些。

数字$1023$被称为双精度格式的指数偏差。

> 它用于将正指数和负指数转换为正二进制数，以便存储在指数位中。
>
> 没看懂。:cry:



今天有点困了，思路不太清晰，且听下回分解。